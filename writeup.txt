Part 2.1 - English/C Desciption:

.include "nios_macros.s"
.global _start
_start:
/* the following two instr. (orhi and ori)are what movia converts to */
orhi    r2, r0, %hi(X) #bitwise logical or immediate into high halfword
ori		r2, r2, %lo(X) #bitwise logical or immediate
movia   r3, Y          #move immediate address into word
movia   r4, N
ldw		r4, 0(r4)      #load 32-bit word from memory or I/O peripheral
add		r5, r0, r0     #add
LABEL:
ldw		r6, 0(r2)      
stw		r6, 0(r3)      #store word to memory or I/O peripheral
addi    r2, r2, 4      #addi
addi    r3, r3, 4
subi    r4, r4, 1      #subtract immediate
bgt		r4, r0, LABEL  #branch if greater than signed
STOP:
br STOP                #unconditional branch
.data
N:
	.word 6
X:
	.word 5, 3, -6, 19, 8, 12
Y:
	.word 0, 0, 0, 0, 0, 0


C-Desription
int X_word[6] = {5, 3, -6, 19, 8, 12};
int Y_word[6];
int N = 6;

int i = 0;
for(i=N-1; i>=0; i--) {
  Y_word[i] = X_word[i];
}


Part 2.2 - Decoding Instructions:

    Answer: stw r3, r4, 0xFFE4

    Work:
        0x993FF915
        0b1001_1001_0011_1111_1111_1001_0001_0101

        OP code:
            0b1_0101
            0x15 -> stw
        IMM16:
            0b1111_1111_1110_0100
            0xFFE4
        rB:
            0b0_0110
            0x04 -> r4
        rA:
            0b1_0011
            0x13 -> r3

Part 2.3 - Encoding Instructions:

    Answer:

    Work:

        divu r14, r5, r22
	
	divu rC, rA, rB
	
	OP code:
        	divu -> 0x24
    		0b100100
        i5:
		0b00000
        OPX:
        rC:
    		0x14
    		0b10100
        rB:
    		0x22
    		0b100010 //this is too many bits!! (May not be an issue -Adam)
        rA:
    		0x05
    		0b00101
		
	R-Type Instruction
	OP	i5	OPX	C	B	A
        001001	00000   ???	00101	010001	10100 
        
